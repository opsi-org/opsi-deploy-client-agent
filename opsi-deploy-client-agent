#! /usr/bin/env python
# -*- coding: utf-8 -*-

# This tool is part of the desktop management solution opsi
# (open pc server integration) http://www.opsi.org
# Copyright (C) 2007-2015 uib GmbH <info@uib.de>

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU Affero General Public License as
# published by the Free Software Foundation, either version 3 of the
# License, or (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Affero General Public License for more details.

# You should have received a copy of the GNU Affero General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.
"""
opsi-deploy-client-agent

This script can be used to deploy the opsi-client-agent to systems
that are already running a Windows Operating System that has not been
installed via opsi.


:copyright: uib GmbH <info@uib.de>
:author: Jan Schneider <j.schneider@uib.de>
:author: Niko Wenselowski <n.wenselowski@uib.de>
:license: GNU Affero General Public License version 3
"""

from __future__ import print_function

import getpass
import os
import re
import shutil
import socket
import sys
import threading
import time

from OPSI.Backend.BackendManager import BackendManager
from OPSI.Logger import Logger, LOG_WARNING, LOG_ERROR
from OPSI.Object import OpsiClient, ProductOnClient
from OPSI.System import copy, execute, getFQDN, umount, which
from OPSI.Types import forceHostId, forceInt, forceIPAddress, forceUnicode, forceUnicodeLower
from OPSI.Util import randomString
from OPSI.Util.File import IniFile

try:
	import argparse
except ImportError:
	from OPSI.Util import argparse

__version__ = '4.0.6.1'


logger = Logger()


def winexe(cmd, host, username, password):
	cmd = forceUnicode(cmd)
	host = forceUnicode(host)
	username = forceUnicode(username)
	password = forceUnicode(password)

	match = re.search('^([^\\\\]+)\\\\+([^\\\\]+)$', username)
	if match:
		username = match.group(1) + u'\\' + match.group(2)

	try:
		executable = which('winexe')
	except Exception as error:
		logger.debug('Getting winexe installed on system failed ({0}) Using local.'.format(error))
		executable = './winexe'

	return execute(u"%s -U '%s' //%s '%s'" % (executable, username + '%' + password.replace("'", "'\"'\"'"), host, cmd))


class SkipClientException(Exception):
	pass


class DeployThread(threading.Thread):
	def __init__(self, host, backend, username, password, shutdown, reboot, startService,
				deploymentMethod="hostname", stopOnPingFailure=True,
				skipExistingClient=False, clientSideMount=True,
				keepClientOnFailure=False):

		threading.Thread.__init__(self)
		self.host = host
		self.backend = backend
		self.username = username
		self.password = password
		self.shutdown = shutdown
		self.reboot = reboot
		self.startService = startService
		self.stopOnPingFailure = stopOnPingFailure
		self.skipExistingClient = skipExistingClient
		self.clientSideMount = clientSideMount

		deploymentMethod = forceUnicodeLower(deploymentMethod)
		if deploymentMethod not in ("hostname", "ip", "fqdn"):
			raise ValueError("Invalid deployment method: {0}".format(deploymentMethod))
		self.deploymentMethod = deploymentMethod

		self.keepClientOnFailure = keepClientOnFailure

	def run(self):
		if self.clientSideMount:
			self._installWithClientSideMount()
		else:
			self._installWithServersideMount()

	def _installWithClientSideMount(self):
		logger.debug('Installing using client-side mount.')
		host = forceUnicodeLower(self.host)
		hostId = u''
		hostObj = None
		try:
			hostId = self._getHostId(host)
			hostName = host.split('.')[0]
			self._checkIfClientShouldBeSkipped(hostId)

			logger.notice(u"Starting deployment to host '%s'" % hostId)

			ipAddress = self._getIpAddress(hostId, hostName)
			self._pingClient(ipAddress)

			logger.notice(u"Getting hardware ethernet address of host '%s'" % hostId)
			mac = self._getMacAddress(ipAddress)
			if not mac:
				logger.warning(u"Failed to get hardware ethernet address for IP {0}".format(ipAddress))

			self._createHostIfNotExisting(hostId, mac, ipAddress)
			hostObj = self.backend.host_getObjects(type='OpsiClient', id=hostId)[0]

			networkAddress = self._getNetworkAddress(hostId, hostName, ipAddress)

			logger.notice(u"Testing winexe")
			cmd = u'cmd.exe /C "del /s /q c:\\tmp\\opsi-client-agent_inst && rmdir /s /q c:\\tmp\\opsi-client-agent_inst || echo not found"'
			for trynum in (1, 2):
				try:
					winexe(cmd, networkAddress, self.username, self.password)
					break
				except Exception as error:
					if trynum == 2:
						raise Exception(u"Failed to execute command on host '%s': winexe error: %s" % (networkAddress, error))
					logger.info(u"Winexe failure '%s', retrying" % error)
					time.sleep(2)

			logger.notice(u"Patching config.ini")
			configIniName = u'%s_config.ini' % randomString(10)
			copy(os.path.join(u'files', u'opsi', u'cfg', u'config.ini'), '/tmp/%s' % configIniName)
			configFile = IniFile('/tmp/%s' % configIniName)
			config = configFile.parse()
			if not config.has_section('shareinfo'):
				config.add_section('shareinfo')
			config.set('shareinfo', 'pckey', hostObj.opsiHostKey)
			if not config.has_section('general'):
				config.add_section('general')
			config.set('general', 'dnsdomain', u'.'.join(hostObj.id.split('.')[1:]))
			configFile.generate(config)

			try:
				logger.notice(u"Copying installation files")
				cmd = u"%s //%s/c$ -U '%s' -c 'prompt; recurse; md tmp; cd tmp; md opsi-client-agent_inst; cd opsi-client-agent_inst; mput files; mput utils; cd files\\opsi\\cfg; lcd /tmp; put %s config.ini; exit;'" \
					% (which('smbclient'), networkAddress, self.username + '%' + self.password.replace("'", "'\"'\"'"), configIniName)
				execute(cmd)

				logger.notice(u"Installing opsi-client-agent")
				cmd = u'c:\\tmp\\opsi-client-agent_inst\\files\\opsi\\opsi-winst\\winst32.exe /batch c:\\tmp\\opsi-client-agent_inst\\files\\opsi\\setup.ins c:\\tmp\\opsi-client-agent.log /PARAMETER REMOTEDEPLOY'
				for trynum in (1, 2):
					try:
						winexe(cmd, networkAddress, self.username, self.password)
						break
					except Exception as error:
						if trynum == 2:
							raise Exception(u"Failed to install opsi-client-agent: %s" % error)
						logger.info(u"Winexe failure '%s', retrying" % error)
						time.sleep(2)
			finally:
				os.remove('/tmp/%s' % configIniName)

				try:
					cmd = u'cmd.exe /C "del /s /q c:\\tmp\\opsi-client-agent_inst && rmdir /s /q c:\\tmp\\opsi-client-agent_inst"'
					winexe(cmd, networkAddress, self.username, self.password)
				except Exception as error:
					logger.error(error)

			logger.notice(u"opsi-client-agent successfully installed on '%s'" % hostId)
			self._setOpsiClientAgentToInstalled(hostId)
			self._finaliseInstallation(networkAddress)
		except SkipClientException:
			logger.notice(u"Skipping host '%s'" % hostId)
			return
		except Exception as error:
			logger.error(u"Deployment to '%s' failed: %s" % (hostId, error))
			if hostObj and not self.keepClientOnFailure:
				self._removeHostFromBackend(hostObj)

	def _getHostId(self, host):
		if self.deploymentMethod == 'ip':
			try:
				(hostname, _, _) = socket.gethostbyaddr(host)
				host = hostname
			except socket.herror as error:
				logger.debug("Lookup failed: {0}".format(error))
				raise Exception("Can't find name for IP {0}: {1}".format(host, error))

		host = host.replace('_', '-')

		if host.count(u'.') < 2:
			try:
				host = socket.getfqdn(socket.gethostbyname(host))
			except socket.gaierror as error:
				logger.debug("Lookup of {0} failed.".format(host))

		if host.count(u'.') < 2:
			hostId = forceHostId(u'{hostname}.{domain}'.format(hostname=host, domain=u'.'.join(getFQDN().split(u'.')[1:])))
		else:
			hostId = forceHostId(host)

		logger.info("Got hostId {0}".format(hostId))
		return hostId

	def _checkIfClientShouldBeSkipped(self, hostId):
		if self.backend.host_getIdents(type='OpsiClient', id=hostId) and self.skipExistingClient:
			raise SkipClientException("Client {0} exists.".format(hostId))

	def _getIpAddress(self, hostId, hostName):
		if self.deploymentMethod == 'ip':
			return forceIPAddress(self.host)

		logger.notice(u"Querying for ip address of host '%s'" % hostId)
		ipAddress = u''
		logger.info(u"Getting host '%s' by name" % hostId)
		try:
			ipAddress = socket.gethostbyname(hostId)
		except Exception as error:
			logger.warning(u"Failed to get ip address for host '%s' by syscall: %s" % (hostId, error))

		if ipAddress:
			logger.notice(u"Got ip address '%s' from syscall" % ipAddress)
		else:
			logger.info(u"Executing 'nmblookup %s#20'" % hostName)
			for line in execute(u"nmblookup %s#20" % hostName):
				match = re.search("^(\d+\.\d+\.\d+\.\d+)\s+%s<20>" % hostName, line, re.IGNORECASE)
				if match:
					ipAddress = match.group(1)
					break
			if ipAddress:
				logger.notice(u"Got ip address '%s' from netbios lookup" % ipAddress)
			else:
				raise Exception(u"Failed to get ip address for host '%s'" % hostName)

		return ipAddress

	def _pingClient(self, ipAddress):
		logger.notice(u"Pinging host %s ..." % ipAddress)
		alive = False
		try:
			for line in execute(u"ping -q -c2 %s" % ipAddress):
				match = re.search("\s+(\d+)%\s+packet\s+loss", line)
				if match and (forceInt(match.group(1)) < 100):
					alive = True
		except Exception as error:
			logger.error(error)

		if alive:
			logger.notice(u"Host %s is up" % ipAddress)
		elif self.stopOnPingFailure:
			raise Exception(u"No ping response received from %s" % ipAddress)
		else:
			logger.warning(u"No ping response received from %s" % ipAddress)

	@staticmethod
	def _getMacAddress(ipAddress):
		mac = u''
		with open("/proc/net/arp") as arptable:
			for line in arptable:
				line = line.strip()
				if not line:
					continue

				if line.split()[0] == ipAddress:
					mac = line.split()[3].lower().strip()
					break

		if not mac or (mac == u'00:00:00:00:00:00'):
			mac = u''
		else:
			logger.notice(u"Found hardware ethernet address '%s'" % mac)

		return mac

	def _createHostIfNotExisting(self, hostId, mac, ipAddress):
		if not self.backend.host_getIdents(type='OpsiClient', id=hostId):
			logger.notice(u"Creating client '%s'" % hostId)

			hostObj = OpsiClient(
				id=hostId,
				hardwareAddress=mac,
				ipAddress=ipAddress,
				description=u"",
				notes=u"Created by opsi-deploy-client-agent at %s" % time.strftime("%a, %d %b %Y %H:%M:%S", time.localtime())
			)
			self.backend.host_createObjects([hostObj])

	def _getNetworkAddress(self, hostId, hostName, ipAddress):
		if self.deploymentMethod == 'hostname':
			return hostName
		elif self.deploymentMethod == 'fqdn':
			return hostId
		else:
			return ipAddress

	def _setOpsiClientAgentToInstalled(self, hostId):
		poc = ProductOnClient(
			productType=u'LocalbootProduct',
			clientId=hostId,
			productId=u'opsi-client-agent',
			installationStatus=u'installed',
			actionResult=u'successful'
		)
		self.backend.productOnClient_updateObjects([poc])

	def _finaliseInstallation(self, networkAddress):
		if self.reboot or self.shutdown:
			if self.reboot:
				logger.notice(u"Rebooting machine '%s'" % networkAddress)
				cmd = u'"%ProgramFiles%\\opsi.org\\opsi-client-agent\\utilities\\shutdown.exe" /L /R /T:20 "opsi-client-agent installed - reboot" /Y /C'
			elif self.shutdown:
				logger.notice(u"Shutting down machine '%s'" % networkAddress)
				cmd = u'"%ProgramFiles%\\opsi.org\\opsi-client-agent\\utilities\\shutdown.exe" /L /T:20 "opsi-client-agent installed - shutdown" /Y /C'

			try:
				pf = None
				for const in ('%ProgramFiles(x86)%', '%ProgramFiles%'):
					try:
						lines = winexe(u'cmd.exe /C "echo %s"' % const, networkAddress, self.username, self.password)
					except Exception as error:
						logger.warning(error)
						continue

					for line in lines:
						line = line.strip()
						if 'unavailable' in line:
							continue
						pf = line

					if pf and pf != const:
						break

					pf = None

				if not pf:
					raise Exception(u"Failed to get program files path")

				logger.info(u"Program files path is '%s'" % pf)
				winexe(cmd.replace(u'%ProgramFiles%', pf), networkAddress, self.username, self.password)
			except Exception as error:
				if self.reboot:
					logger.error(u"Failed to reboot computer: %s" % error)
				else:
					logger.error(u"Failed to shutdown computer: %s" % error)
		elif self.startService:
			try:
				winexe(u'net start opsiclientd', networkAddress, self.username, self.password)
			except Exception as error:
				logger.error("Failed to start opsiclientd on {host}: {error}".format(host=networkAddress, error=error))

	def _removeHostFromBackend(self, host):
		try:
			logger.notice('Deleting client {0} from backend.'.format(hostObj))
			self.backend.host_deleteObjects([hostObj])
		except Exception as anotherError:
			logger.error(anotherError)

	def _installWithServersideMount(self):
		logger.debug('Installing using server-side mount.')
		host = forceUnicodeLower(self.host)
		hostId = u''
		hostObj = None
		mountDir = u''
		instDir = u''
		try:
			hostId = self._getHostId(host)
			hostName = host.split('.')[0]
			self._checkIfClientShouldBeSkipped(hostId)

			logger.notice(u"Starting deployment to host '%s'" % hostId)

			ipAddress = self._getIpAddress(hostId, hostName)
			self._pingClient(ipAddress)

			logger.notice(u"Getting hardware ethernet address of host '%s'" % hostId)
			mac = self._getMacAddress(ipAddress)
			if not mac:
				logger.warning(u"Failed to get hardware ethernet address for IP {0}".format(ipAddress))

			self._createHostIfNotExisting(hostId, mac, ipAddress)
			hostObj = self.backend.host_getObjects(type='OpsiClient', id=hostId)[0]

			networkAddress = self._getNetworkAddress(hostId, hostName, ipAddress)

			mountDir = os.path.join(u'/tmp', u'mnt_' + randomString(10))
			os.makedirs(mountDir)

			logger.notice(u"Mounting c$ share")
			try:
				try:
					execute(u"%s -t cifs -o'username=%s,password=%s' //%s/c$ %s" % (which('mount'), self.username, self.password.replace("'", "'\"'\"'"), networkAddress, mountDir), timeout=15)
				except Exception as error:
					logger.info(u"Failed to mount clients c$ share: %s, retrying with port 139" % error)
					execute(u"%s -t cifs -o'port=139,username=%s,password=%s' //%s/c$ %s" % (which('mount'), self.username, self.password.replace("'", "'\"'\"'"), networkAddress, mountDir), timeout=15)
			except Exception as error:
				raise Exception(u"Failed to mount c$ share: %s\nPerhaps you have to disable the firewall or simple file sharing on the windows machine (folder options)?" % error)

			logger.notice(u"Copying installation files")
			instDirName = u'opsi_{random}'.format(random=randomString(10))
			instDir = os.path.join(mountDir, instDirName)
			os.makedirs(instDir)

			copy(u'files', instDir)
			copy(u'utils', instDir)

			logger.notice(u"Patching config.ini")
			configFile = IniFile(os.path.join(instDir, u'files', u'opsi', u'cfg', u'config.ini'))
			config = configFile.parse()
			if not config.has_section('shareinfo'):
				config.add_section('shareinfo')
			config.set('shareinfo', 'pckey', hostObj.opsiHostKey)
			if not config.has_section('general'):
				config.add_section('general')
			config.set('general', 'dnsdomain', u'.'.join(hostObj.id.split('.')[1:]))
			configFile.generate(config)

			logger.notice(u"Installing opsi-client-agent")
			if not os.path.exists(os.path.join(mountDir, 'tmp')):
				os.makedirs(os.path.join(mountDir, 'tmp'))
			cmd = u'c:\\%s\\files\\opsi\\opsi-winst\\winst32.exe /batch c:\\%s\\files\\opsi\\setup.ins c:\\tmp\\opsi-client-agent.log /PARAMETER REMOTEDEPLOY' % (instDirName, instDirName)
			for trynum in (1, 2):
				try:
					winexe(cmd, networkAddress, self.username, self.password)
					break
				except Exception as error:
					if trynum == 2:
						raise Exception(u"Failed to install opsi-client-agent: %s" % error)
					logger.info(u"Winexe failure '%s', retrying" % error)
					time.sleep(2)

			logger.notice(u"opsi-client-agent successfully installed on '%s'" % hostId)
			self._setOpsiClientAgentToInstalled(hostId)
			self._finaliseInstallation(networkAddress)
		except SkipClientException:
			logger.notice(u"Skipping host '%s'" % hostId)
			return
		except Exception as error:
			logger.error(u"Deployment to '%s' failed: %s" % (hostId, error))
			if hostObj and not self.keepClientOnFailure:
				self._removeHostFromBackend(hostObj)
		finally:
			if instDir or mountDir:
				logger.notice(u"Cleaning up")

			if instDir:
				try:
					shutil.rmtree(instDir)
				except OSError as err:
					logger.debug('Removing {0} failed: {1}'.format(instDir, err))

			if mountDir:
				try:
					umount(mountDir)
				except Exception as err:
					logger.warning('Unmounting {0} failed: {1}'.format(mountDir, err))

				try:
					os.rmdir(mountDir)
				except OSError as err:
					logger.debug('Removing {0} failed: {1}'.format(instDir, err))


def main(argv):
	parser = argparse.ArgumentParser(
		description=(
			u"Deploy opsi client agent to the specified clients.\n"
			u"The c$ and admin$ must be accessable on every client.\n"
			u"Simple File Sharing (Folder Options) should be disabled on the Windows machine."
		)
	)
	parser.add_argument('-V', action='version', version=__version__)
	parser.add_argument('-v', dest="logLevel", default=LOG_WARNING, action="count",
						help="increase verbosity (can be used multiple times)")
	parser.add_argument('-u', dest="username", default=u"Administrator",
						help=(
							u'username for authentication (default: Administrator).\n'
							u"example for a domain account: -u \"<DOMAIN>\\\\<username>\""
							)
						)
	parser.add_argument('-p', dest="password", default=u"",
						help=u"password for authentication")
	group = parser.add_mutually_exclusive_group()
	group.add_argument('-c', '--use-fqdn', dest="useNetbios",
						action="store_false",
						help=u"Use FQDN to connect to client.")
	group.add_argument('--use-hostname', dest="useNetbios", default=False,
						action="store_true",
						help=u"Use hostname to connect to client. (Default)")
	group.add_argument('--use-ip-address', dest="useIPAddress",
						action='store_true',
						help="Use IP address to connect to client.")
	parser.add_argument('-x', dest="stopOnPingFailure", default=True,
						action="store_false",
						help=u"try installation even if ping fails")
	parser.add_argument('-r', dest="reboot", default=False, action="store_true",
						help=u"reboot computer after installation")
	parser.add_argument('-s', dest="shutdown", default=False,
						action="store_true",
						help=u"shutdown computer after installation")
	parser.add_argument('-o', dest="startService", default=False,
						action="store_true",
						help=u"start opsiclientd service after installation")
	parser.add_argument('-f', dest="hostFile", default=None,
						help=u"file containing list of clients (one hostname per line)")
	parser.add_argument('-S', dest="skipExistingClient", default=False,
						action="store_true",
						help=u"skip known opsi clients")
	parser.add_argument('-t', dest="maxThreads", default=1, type=int,
						help=u"number of concurrent deployment threads")
	parser.add_argument('--server-side-mount', dest="clientSideMount",
						default=True, action="store_false",
						help=u"Mount the client's C$-share on the server for copying the files. This imitates the behaviour of the old script.")
	parser.add_argument('--keep-client-on-failure', dest="keepClientOnFailure",
						default=False, action="store_true",
						help=(u"If the client was created in opsi and "
								u"anything fails after that the client is "
								u"not removed."))
	parser.add_argument('host', nargs='*',
						help='The hosts to deploy the opsi-client-agent to.')

	args = parser.parse_args(argv)

	logger.setConsoleLevel(args.logLevel)

	hosts = args.host
	if args.hostFile:
		if not os.path.isfile(args.hostFile):
			raise Exception(u"File '%s' not found!" % args.hostFile)

		with open(args.hostFile) as inputFile:
			for line in inputFile:
				line = line.strip()
				if not line or line.startswith('#') or line.startswith(';'):
					continue

				hosts.append(forceUnicodeLower(line))

	if not hosts:
		raise Exception("No hosts given.")

	logger.debug('Deploying to the following hosts: {0}'.format(hosts))

	password = args.password
	if not password:
		print("Password is required for deployment.")
		password = forceUnicode(getpass.getpass())
		if not password:
			raise Exception("No password given.")

	logger.addConfidentialString(password)

	maxThreads = forceInt(args.maxThreads)
	if maxThreads < 1:
		maxThreads = 1

	if not args.clientSideMount:
		if os.getuid() != 0:
			raise Exception("You have to be root to use server-side-mouting.")

	if args.useIPAddress:
		deploymentMethod = "ip"
	elif args.useNetbios:
		deploymentMethod = "hostname"
	else:
		deploymentMethod = "fqdn"

	# Create BackendManager
	backend = BackendManager(
		dispatchConfigFile=u'/etc/opsi/backendManager/dispatch.conf',
		backendConfigDir=u'/etc/opsi/backends',
		extend=True,
		depotbackend=False,
		hostControlBackend=False
	)
	runningThreads = []
	while hosts:
		while len(runningThreads) > maxThreads:
			time.sleep(1)
			for thread in runningThreads:
				if thread.isAlive():
					continue
				runningThreads.remove(thread)
				break

		host = hosts.pop()
		thread = DeployThread(host, backend,
			args.username,
			password,
			args.shutdown,
			args.reboot,
			args.startService,
			deploymentMethod,
			args.stopOnPingFailure,
			args.skipExistingClient,
			args.clientSideMount,
			args.keepClientOnFailure
		)
		thread.start()
		runningThreads.append(thread)
		time.sleep(0.5)

	for thread in runningThreads:
		if thread.isAlive():
			thread.join()


if __name__ == "__main__":
	logger.setConsoleLevel(LOG_WARNING)
	logger.setLogFormat('[%L] %M')
	logger.setConsoleColor(True)

	try:
		os.chdir(os.path.dirname(os.path.abspath(__file__)))
		main(sys.argv[1:])
	except Exception as error:
		logger.setConsoleLevel(LOG_ERROR)
		logger.logException(error)
		print(u"ERROR: %s" % forceUnicode(error), file=sys.stderr)
		sys.exit(1)

	sys.exit(0)
